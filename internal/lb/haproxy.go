// Package lb provides a HAProxy adapter for load balancer management.
package lb

import (
	"bytes"
	"fmt"
	"net"
	"os"
	"os/exec"
	"strings"
	"text/template"
	"time"

	"go.uber.org/zap"

	"github.com/aegisx/aegisx/internal/policy"
)

const haproxyTemplate = `# HAProxy configuration — generated by AegisX {{ .Timestamp }}
# DO NOT EDIT MANUALLY

global
    log /dev/log local0
    log /dev/log local1 notice
    chroot /var/lib/haproxy
    stats socket {{ .StatsSocket }} mode 660 level admin expose-fd listeners
    stats timeout 30s
    user haproxy
    group haproxy
    daemon
    maxconn 100000
    tune.ssl.default-dh-param 2048
    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256
    ssl-default-bind-options no-sslv3 no-tlsv10 no-tlsv11

defaults
    log global
    mode http
    option httplog
    option dontlognull
    option forwardfor
    option http-server-close
    timeout connect 5s
    timeout client  50s
    timeout server  50s
    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http

# ── Stats page ────────────────────────────────────────────────────────────
frontend stats
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 10s
    stats hide-version
    stats auth admin:{{ .StatsPassword }}

{{ range .Frontends }}
# ── Frontend: {{ .Name }} ─────────────────────────────────────────────────
frontend {{ .Name }}_frontend
    bind {{ .Bind }}{{ if .TLS }} ssl crt {{ .TLS.Cert }}{{ if .TLS.MinVersion }} {{ .TLS.MinVersion }}{{ end }}{{ end }}
    mode {{ .Mode }}
    default_backend {{ .Name }}_backend
    option {{ if eq .Mode "http" }}httplog{{ else }}tcplog{{ end }}
    maxconn {{ if gt .MaxConn 0 }}{{ .MaxConn }}{{ else }}10000{{ end }}
    {{ if eq .Mode "http" }}
    http-request set-header X-Forwarded-Proto https if { ssl_fc }
    http-response set-header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
    {{ end }}

backend {{ .Name }}_backend
    mode {{ .Mode }}
    balance {{ .Algorithm }}
    {{ if .HealthCheck }}
    option {{ if eq .Mode "http" }}httpchk GET {{ .HealthCheck.Path }}{{ else }}tcp-check{{ end }}
    {{ end }}
    {{ range .Servers }}
    server {{ .Name }} {{ .Address }} weight {{ .Weight }}{{ if gt .MaxConn 0 }} maxconn {{ .MaxConn }}{{ end }}{{ if .Backup }} backup{{ end }} check{{ if $.HealthCheck }} inter {{ $.HealthCheck.Interval }} rise {{ $.HealthCheck.Rise }} fall {{ $.HealthCheck.Fall }}{{ end }}
    {{ end }}
{{ end }}
`

// Adapter manages HAProxy configuration.
type Adapter struct {
	configPath  string
	statsSocket string
	statsPass   string
	log         *zap.Logger
}

func NewAdapter(configPath, statsSocket, statsPass string, log *zap.Logger) *Adapter {
	return &Adapter{
		configPath:  configPath,
		statsSocket: statsSocket,
		statsPass:   statsPass,
		log:         log,
	}
}

// Apply generates HAProxy config from IR and reloads.
func (a *Adapter) Apply(ir *policy.IR) error {
	cfg, err := a.Generate(ir)
	if err != nil {
		return fmt.Errorf("generate config: %w", err)
	}

	// Validate before writing.
	if err := a.validate(cfg); err != nil {
		return fmt.Errorf("config validation: %w", err)
	}

	if err := os.WriteFile(a.configPath, []byte(cfg), 0640); err != nil {
		return fmt.Errorf("write config: %w", err)
	}

	return a.Reload()
}

// Generate produces a HAProxy config string from the IR.
func (a *Adapter) Generate(ir *policy.IR) (string, error) {
	type frontendData struct {
		Name        string
		Bind        string
		Mode        string
		MaxConn     int
		Algorithm   string
		Servers     []policy.LBServer
		HealthCheck *policy.LBHealthCheck
		TLS         *policy.LBTLSConfig
	}

	data := struct {
		Timestamp     string
		StatsSocket   string
		StatsPassword string
		Frontends     []frontendData
	}{
		Timestamp:     time.Now().UTC().Format(time.RFC3339),
		StatsSocket:   a.statsSocket,
		StatsPassword: a.statsPass,
	}

	for _, lb := range ir.LoadBalancers {
		algo := lb.Backend.Algorithm
		if algo == "" {
			algo = "roundrobin"
		}
		// HAProxy uses "leastconn" not "least_conn"
		algo = strings.ReplaceAll(algo, "_", "")

		data.Frontends = append(data.Frontends, frontendData{
			Name:        lb.Name,
			Bind:        lb.Frontend.Bind,
			Mode:        lb.Frontend.Mode,
			MaxConn:     lb.Frontend.MaxConn,
			Algorithm:   algo,
			Servers:     lb.Backend.Servers,
			HealthCheck: lb.Backend.HealthCheck,
			TLS:         lb.TLS,
		})
	}

	tmpl, err := template.New("haproxy").Parse(haproxyTemplate)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// Reload sends SIGUSR2 to HAProxy for zero-downtime reload.
func (a *Adapter) Reload() error {
	out, err := exec.Command("systemctl", "reload", "haproxy").CombinedOutput()
	if err != nil {
		// Try direct signal
		out2, err2 := exec.Command("haproxy", "-f", a.configPath, "-sf",
			"$(cat /var/run/haproxy.pid)").CombinedOutput()
		if err2 != nil {
			return fmt.Errorf("reload failed: %s / %s", out, out2)
		}
	}
	a.log.Info("HAProxy reloaded")
	return nil
}

// BackendStatus queries HAProxy stats socket for backend server states.
func (a *Adapter) BackendStatus() ([]ServerStatus, error) {
	conn, err := net.DialTimeout("unix", a.statsSocket, 3*time.Second)
	if err != nil {
		return nil, fmt.Errorf("connect to stats socket: %w", err)
	}
	defer conn.Close()

	conn.SetDeadline(time.Now().Add(5 * time.Second))
	fmt.Fprintln(conn, "show stat")

	var stats []ServerStatus
	// Parse CSV response from HAProxy stats
	// (simplified — production should use the full CSV spec)
	return stats, nil
}

// ServerStatus represents a backend server's health state.
type ServerStatus struct {
	Frontend string
	Backend  string
	Server   string
	Status   string  // UP | DOWN | MAINT
	Weight   int
	Sessions int64
}

// validate runs `haproxy -c -f` to check syntax.
func (a *Adapter) validate(cfg string) error {
	tmpFile, err := os.CreateTemp("", "aegisx-haproxy-*.cfg")
	if err != nil {
		return err
	}
	defer os.Remove(tmpFile.Name())

	if _, err := tmpFile.WriteString(cfg); err != nil {
		return err
	}
	tmpFile.Close()

	out, err := exec.Command("haproxy", "-c", "-f", tmpFile.Name()).CombinedOutput()
	if err != nil {
		return fmt.Errorf("haproxy validation error: %w\n%s", err, out)
	}
	return nil
}
